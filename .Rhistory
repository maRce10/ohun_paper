# get pakage name
pkg <- strsplit(y, "/")[[1]]
pkg <- pkg[length(pkg)]
# check if installed, if not then install
if (!pkg %in% installed.packages()[,"Package"])  {
if (grepl("/", y))  remotes::install_github(y, force = TRUE) else
install.packages(y)
}
# load package
try(require(pkg, character.only = T), silent = T)
})
opts_knit$set(root.dir = "..")
opts_chunk$set( fig.width = 8, fig.height = 3.5)
data_path <- "./data/raw/thyroptera/"
library(warbleR)
library(ggplot2)
library(viridis)
warbleR_options(wav.path = "./data/raw/thyroptera/", wl = 300, parallel = 1, bp = "frange", fast = F, threshold = 15, ovlp = 20)
setwd("~/Dropbox/Projects/ohun_paper")
warbleR_options(wav.path = "./data/raw/thyroptera/", wl = 300, parallel = 1, bp = "frange", fast = F, threshold = 15, ovlp = 20)
getwd()
warbleR_options(wav.path = "./data/raw/thyroptera/", wl = 300, parallel = 1, bp = "frange", fast = F, threshold = 15, ovlp = 20)
# read data
manual_ref <- read.csv("./data/raw/thyroptera/manual_annotations_thyroptera.csv", stringsAsFactors = FALSE)
manual_ref <- read.csv("./data/raw/thyroptera/manual_annotations_thyroptera.csv", stringsAsFactors = FALSE)
# select highest signal to noise ratio calls per individual
manual_ref_snr <- signal_2_noise(X = manual_ref, mar = 0.05)
high_snr <- manual_ref_snr[ave(-manual_ref_snr$SNR, manual_ref_snr$sound.files, FUN = rank) <= 1, ]
train_files <- sample(unique(manual_ref$sound.files), size = 5)
test_files <- setdiff(manual_ref$sound.files, train_files)
set.seed(1)
train_files <- sample(unique(manual_ref$sound.files), size = 5)
test_files <- setdiff(manual_ref$sound.files, train_files)
train_ref <- manual_ref[manual_ref$sound.files %in% train_files, ]
test_ref <- manual_ref[manual_ref$sound.files %in% test_files, ]
# find templates
templates <- get_templates(train_ref, path = data_path,  bp = c(10, 50), fast = TRUE, ovlp = , wl = 200, n.sub.spaces = 3)
data_path
templates <- get_templates(train_ref, path = data_path,  bp = c(10, 50), fast = TRUE, ovlp = , wl = 200, n.sub.spaces = 3)
templates_est <- selection_table(templates, extended = TRUE, confirm.extended = FALSE, path = data_path)
templates_est <- rename_est_waves(templates_est, new.sound.files = templates$template)
corr_templ_train <- template_correlator(
templates = templates_est,
path = data_path,
files = unique(train_ref$sound.files),
hop.size = 10,
ovlp = 70
)
opt_detec_train <- optimize_template_detector(
reference = train_ref,
template.correlations = corr_templ_train,
threshold = seq(0.1, 0.9, 0.05)
)
saveRDS(templates_est, "./data/processed/templates_thyroptera_est.RDS")
opt_detec_train
opt_detec_train$templates <- gsub("-1$", "", opt_detec_train$templates)
saveRDS(opt_detec_train, "./data/processed/optimization_results_3_templates_thyroptera.RDS")
saveRDS(opt_detec_train, "./data/processed/optimization_results_3_templates_thyroptera.RDS")
agg_f1 <- aggregate(f1.score ~ threshold + templates, data = opt_detec_train,
mean)
ggplot(agg_f1, aes(x = threshold, y = f1.score, group = templates, color = templates)) +
geom_line() + geom_point() + scale_color_viridis_d(end = 1) + theme_classic()
f1.score
opt_detec_train
View(opt_detec_train)
remove.packages("ohun")
remotes::install_github("maRce10/ohun")
remotes::install_github("maRce10/ohun")
#load package
library(ohun)
## add 'developer/' to packages to be installed from github
x <- c("remotes", "maRce10/warbleR", "bioacoustics", "viridis", "ggplot2", "maRce10/ohun", "DT")
aa <- lapply(x, function(y) {
# get pakage name
pkg <- strsplit(y, "/")[[1]]
pkg <- pkg[length(pkg)]
# check if installed, if not then install
if (!pkg %in% installed.packages()[,"Package"])  {
if (grepl("/", y))  remotes::install_github(y, force = TRUE) else
install.packages(y)
}
# load package
try(require(pkg, character.only = T), silent = T)
})
library(warbleR)
library(ggplot2)
library(viridis)
data_path <- "./data/raw/thyroptera/"
warbleR_options(wav.path = "./data/raw/thyroptera/", wl = 300, parallel = 1, bp = "frange", fast = F, threshold = 15, ovlp = 20)
warbleR_options(wav.path = "./data/raw/thyroptera/", wl = 300, parallel = 1, bp = "frange", fast = F, threshold = 15, ovlp = 20)
manual_ref <- read.csv("./data/raw/thyroptera/manual_annotations_thyroptera.csv", stringsAsFactors = FALSE)
# select highest signal to noise ratio calls per individual
manual_ref_snr <- signal_2_noise(X = manual_ref, mar = 0.05)
# select 1 example per sound file
high_snr <- manual_ref_snr[ave(-manual_ref_snr$SNR, manual_ref_snr$sound.files, FUN = rank) <= 1, ]
set.seed(1)
train_files <- sample(unique(manual_ref$sound.files), size = 5)
test_files <- setdiff(manual_ref$sound.files, train_files)
train_ref <- manual_ref[manual_ref$sound.files %in% train_files, ]
test_ref <- manual_ref[manual_ref$sound.files %in% test_files, ]
# find templates
templates <- get_templates(train_ref, path = data_path,  bp = c(10, 50), fast = TRUE, ovlp = , wl = 200, n.sub.spaces = 3)
templates <- get_templates(train_ref, path = data_path,  bp = c(10, 50), fast = TRUE, ovlp = , wl = 200, n.sub.spaces = 3)
# create ext. selection table
templates_est <- selection_table(templates, extended = TRUE, confirm.extended = FALSE, path = data_path)
templates_est <- rename_est_waves(templates_est, new.sound.files = templates$template)
saveRDS(templates_est, "./data/processed/templates_thyroptera_est.RDS")
saveRDS(templates_est, "./data/processed/templates_thyroptera_est.RDS")
aral <- 10
corr_templ_train <- template_correlator(
templates = templates_est,
path = data_path,
files = unique(train_ref$sound.files),
parallel = paral,
hop.size = 10,
ovlp = 70
)
paral <- 10
aral <- 10
corr_templ_train <- template_correlator(
templates = templates_est,
path = data_path,
files = unique(train_ref$sound.files),
parallel = paral,
hop.size = 10,
ovlp = 70
)
opt_detec_train <- optimize_template_detector(
reference = train_ref,
template.correlations = corr_templ_train,
threshold = seq(0.1, 0.9, 0.05),
parallel = paral
)
paral <- 10
corr_templ_train <- template_correlator(
templates = templates_est,
path = data_path,
files = unique(train_ref$sound.files),
cores = paral,
hop.size = 10,
ovlp = 70
)
opt_detec_train <- optimize_template_detector(
reference = train_ref,
template.correlations = corr_templ_train,
threshold = seq(0.1, 0.9, 0.05),
cores = paral
)
opt_detec_train$templates <- gsub("-1$", "", opt_detec_train$templates)
saveRDS(opt_detec_train, "./data/processed/optimization_results_3_templates_thyroptera.RDS")
opt_detec_train <- readRDS("./data/processed/optimization_results_3_templates_thyroptera.RDS")
agg_f1 <- aggregate(f1.score ~ threshold + templates, data = opt_detec_train,
mean)
agg_f <- aggregate(f.score ~ threshold + templates, data = opt_detec_train,
mean)
ggplot(agg_f, aes(x = threshold, y = f.score, group = templates, color = templates)) +
geom_line() + geom_point() + scale_color_viridis_d(end = 1) + theme_classic()
# subset with highest performance
opt_detec_train <- opt_detec_train[order(opt_detec_train$f.score, decreasing = TRUE), ]
sub_opt_detec_train <- opt_detec_train[1:10, c("templates","threshold", "true.positives", "false.positives",  "false.negatives", "recall", "precision", "f.score")]
# print dynamic table
oa_DT <- datatable(sub_opt_detec_train, editable = list(target = "row"), rownames = FALSE, style = "bootstrap",
filter = "top", options = list(pageLength = 100, autoWidth = TRUE, dom = "ft"),
autoHideNavigation = TRUE, escape = FALSE)
formatRound(table = oa_DT, columns = sapply(sub_opt_detec_train, is.numeric), 3)
# get correlation vectors for test files
corr_templ_test <- template_correlator(
templates = templates_est[templates_est$sound.file == "centroid", ],
path = data_path, files = unique(test_ref$sound.files),
hop.size = 10,
ovlp = 70
)
# get correlation vectors for test files
corr_templ_test <- template_correlator(
templates = templates_est[templates_est$sound.file == "centroid", ],
path = data_path, files = unique(test_ref$sound.files),
hop.size = 10,
ovlp = 70
)
corr_templ_test <- template_correlator(
templates = templates_est[templates_est$sound.file == "centroid", ],
path = data_path, files = unique(test_ref$sound.files),
hop.size = 10,
ovlp = 70, cores = 10)
detec_test <- template_detector(
template.correlations = corr_templ_test,
threshold = 0.45, cores = 10
)
diagnose_detection(reference = test_ref, detection = detec_test)
saveRDS(detec_test, "./data/processed/detection_thyroptera_all_67%_template.RDS")
saveRDS(detec_test, "./data/processed/detection_thyroptera_all_67%_template.RDS")
dd <-diagnose_detection(reference = test_ref, detection = detec_test)
dd
dd$f.score
dd <-diagnose_detection(reference = test_ref, detection = detec_test)
dd
dd$f.score
round(dd$f.score, 3)
detec_test <- readRDS("./data/processed/detection_thyroptera_all_67%_template.RDS")
dd <-diagnose_detection(reference = test_ref, detection = detec_test)
dd
dd$f.score
round(dd$f.score, 3)
typeof((dd$f.score))
typeof((dd$f.score))
opt_detec_train$f.score
round(max(opt_detec_train$f.score), 3)
dd$f.score
round(max(opt_detec_train$f.score), 3)
knitr::opts_knit$set(root.dir = normalizePath(".."))
knitr::opts_chunk$set(include = TRUE, eval = TRUE)
data_path <- raw_data_path <- "data/raw/taeniopygia"
preproc_path <- "data/processed/taeniopygia"
figure_path <- "data/processed/taeniopygia/figures"
getwd()
source("~/Dropbox/R_package_testing/ohun/R/diagnose_detection.R")
dd <-diagnose_detection(reference = test_ref, detection = detec_test)
detection = detec_test
dd <-diagnose_detection(reference = test_ref, detection = detec_test)
dd$f.score
detec_test <- readRDS("./data/processed/detection_thyroptera_all_67%_template.RDS")
## add 'developer/' to packages to be installed from github
x <- c("remotes", "maRce10/warbleR", "bioacoustics", "viridis", "ggplot2", "maRce10/ohun", "DT")
aa <- lapply(x, function(y) {
# get pakage name
pkg <- strsplit(y, "/")[[1]]
pkg <- pkg[length(pkg)]
# check if installed, if not then install
if (!pkg %in% installed.packages()[,"Package"])  {
if (grepl("/", y))  remotes::install_github(y, force = TRUE) else
install.packages(y)
}
# load package
try(require(pkg, character.only = T), silent = T)
})
opts_knit$set(root.dir = "..")
opts_chunk$set( fig.width = 8, fig.height = 3.5)
data_path <- "./data/raw/thyroptera/"
library(warbleR)
library(ggplot2)
library(viridis)
# read data
manual_ref <- read.csv("./data/raw/thyroptera/manual_annotations_thyroptera.csv", stringsAsFactors = FALSE)
detec_test <- readRDS("./data/processed/detection_thyroptera_all_67%_template.RDS")
dd <-diagnose_detection(reference = test_ref, detection = detec_test)
dd
dd$f.score
manual_ref <- read.csv("./data/raw/thyroptera/manual_annotations_thyroptera.csv", stringsAsFactors = FALSE)
# select highest signal to noise ratio calls per individual
manual_ref_snr <- signal_2_noise(X = manual_ref, mar = 0.05)
# select 1 example per sound file
high_snr <- manual_ref_snr[ave(-manual_ref_snr$SNR, manual_ref_snr$sound.files, FUN = rank) <= 1, ]
set.seed(1)
train_files <- sample(unique(manual_ref$sound.files), size = 5)
test_files <- setdiff(manual_ref$sound.files, train_files)
train_ref <- manual_ref[manual_ref$sound.files %in% train_files, ]
test_ref <- manual_ref[manual_ref$sound.files %in% test_files, ]
opt_detec_train <- readRDS("./data/processed/optimization_results_3_templates_thyroptera.RDS")
opt_detec_train <- opt_detec_train[order(opt_detec_train$f.score, decreasing = TRUE), ]
sub_opt_detec_train <- opt_detec_train[1:10, c("templates","threshold", "true.positives", "false.positives",  "false.negatives", "recall", "precision", "f.score")]
sub_opt_detec_train
diagnose_detection(reference = test_ref, detection = detec_test)
dd <-diagnose_detection(reference = test_ref, detection = detec_test)
dd
dd <-diagnose_detection(reference = test_ref, detection = detec_test)
dd
dd$f.score
source("~/Dropbox/R_package_testing/ohun/R/diagnose_detection.R")
knitr::opts_knit$set(root.dir = "..")
knitr::opts_chunk$set(include = TRUE, eval = TRUE)
data_path <- raw_data_path <- "data/raw/taeniopygia"
preproc_path <- "data/processed/taeniopygia"
figure_path <- "data/processed/taeniopygia/figures"
source("~/Dropbox/R_package_testing/ohun/R/diagnose_detection.R")
source("~/Dropbox/R_package_testing/ohun/R/label_detection.R")
source("~/Dropbox/R_package_testing/ohun/R/summarize_diagnostic.R")
source("~/Dropbox/R_package_testing/ohun/R/internal_functions.R")
opt_det
opt_det <- optimize_energy_detector(
reference = train_ref,
files = train_files,
threshold = c(1, 5),
hop.size = 11.6,
smooth = c(5, 10),
hold.time = c(0, 5),
min.duration = c(5, 15, 25),
max.duration = c(275, 300, 325),
bp = c(0.5, 10),
path = data_path
)
opt_det <- optimize_energy_detector(
reference = train_ref,
files = train_files,
threshold = c(1, 5),
hop.size = 11.6,
smooth = c(5, 10),
hold.time = c(0, 5),
min.duration = c(5, 15, 25),
max.duration = c(275, 300, 325),
bp = c(0.5, 10),
path = data_path
)
manual_ref_tae <- read.csv(file.path(rootdir, "/data/processed/taeniopygia", "manual_selections_Taeniopygia.csv"))
set.seed(450)
train_files <- sample(unique(manual_ref_tae$sound.files), 3)
test_files <- setdiff(manual_ref_tae$sound.files, train_files)
train_ref <- manual_ref_tae[manual_ref_tae$sound.files %in% train_files, ]
test_ref <- manual_ref_tae[manual_ref_tae$sound.files %in% test_files, ]
opt_det_train <- optimize_energy_detector(
reference = train_ref,
files = train_files,
threshold = c(1, 5),
hop.size = 11.6,
smooth = c(5, 10),
hold.time = c(0, 5),
min.duration = c(5, 15, 25),
max.duration = c(275, 300, 325),
bp = c(0.5, 10), cores = 10
)
train_ref
train_files
train_ref
train_files
opt_det_train <- optimize_energy_detector(
reference = train_ref,
files = train_files,
threshold = c(1, 5),
hop.size = 11.6,
smooth = c(5, 10),
hold.time = c(0, 5),
min.duration = c(5, 15, 25),
max.duration = c(275, 300, 325),
bp = c(0.5, 10)
)
opt_det_train <- optimize_energy_detector(
reference = train_ref,
files = train_files,
threshold = c(1, 5),
hop.size = 11.6,
smooth = c(5, 10),
hold.time = c(0, 5),
min.duration = c(5, 15, 25),
max.duration = c(275, 300, 325),
bp = c(0.5, 10)
)
path_zebra_finch <- file.path(rootdir, "data/raw/taeniopygia/")
# read data
manual_ref_thy <- read.csv(file.path(rootdir, "//data/raw/thyroptera/", "manual_annotations_thyroptera.csv"))
manual_ref_tae <- read.csv(file.path(rootdir, "/data/processed/taeniopygia", "manual_selections_Taeniopygia.csv"))
# github packages must include user name ("user/package")
# knitr is require for creating html/pdf/word reports
# kableExtra is used to print pretty formatted tables
# formatR is used for soft-wrapping code
# klippy is used for adding a copy button to each code block
pkgs <- c("kableExtra", "knitr", "rprojroot", "sciRmdTheme", "rmdwc", "whereami", "maRce10/ohun", "ggplot2", "viridis", "rmdwc", "RefManageR", "bibtex")
# install/ load packages
out <- lapply(pkgs, function(y) {
# get pakage name
pkg <- strsplit(y, "/")[[1]]
pkg <- pkg[length(pkg)]
# check if installed, if not then install
if (!pkg %in% installed.packages()[,"Package"])  {
if (grepl("/", y))  remotes::install_github(y, force = TRUE) else
install.packages(y)
}
# load package
a <- try(require(pkg, character.only = T), silent = T)
if (!a) remove.packages(pkg)
})
# set working directory as project directory or one directory above,
rootdir <- try(rprojroot::find_rstudio_root_file(), silent = TRUE)
if (is(rootdir, "try-error")) rootdir <-  ".."
opts_knit$set(root.dir = rootdir)
# options to customize chunk outputs
knitr::opts_chunk$set(
class.source = "numberLines lineAnchors", # for code line numbers
tidy.opts = list(width.cutoff = 65),
tidy = TRUE,
message = TRUE,
warning = FALSE
)
path_zebra_finch
# Chunk 1: load packages
# github packages must include user name ("user/package")
# knitr is require for creating html/pdf/word reports
# kableExtra is used to print pretty formatted tables
# formatR is used for soft-wrapping code
# klippy is used for adding a copy button to each code block
pkgs <- c("kableExtra", "knitr", "rprojroot", "sciRmdTheme", "rmdwc", "whereami", "maRce10/ohun", "ggplot2", "viridis", "rmdwc", "RefManageR", "bibtex")
# install/ load packages
out <- lapply(pkgs, function(y) {
# get pakage name
pkg <- strsplit(y, "/")[[1]]
pkg <- pkg[length(pkg)]
# check if installed, if not then install
if (!pkg %in% installed.packages()[,"Package"])  {
if (grepl("/", y))  remotes::install_github(y, force = TRUE) else
install.packages(y)
}
# load package
a <- try(require(pkg, character.only = T), silent = T)
if (!a) remove.packages(pkg)
})
# Chunk 2: theme setting
# simplest default settings
sciRmdTheme::set.theme()
# Chunk 3: custom data frame printing
# this is a customized printing style data frames
# screws up tibble function
tibble <- function(x, ...) {
x <- kbl(x, digits=3, align= 'c', row.names = FALSE)
x <- kable_styling(x, position ="center", full_width = FALSE,  bootstrap_options = c("striped", "hover", "condensed", "responsive"))
asis_output(x)
}
registerS3method("knit_print", "data.frame", tibble)
# Chunk 4: set working directory
# set working directory as project directory or one directory above,
rootdir <- try(rprojroot::find_rstudio_root_file(), silent = TRUE)
if (is(rootdir, "try-error")) rootdir <-  ".."
opts_knit$set(root.dir = rootdir)
# options to customize chunk outputs
knitr::opts_chunk$set(
class.source = "numberLines lineAnchors", # for code line numbers
tidy.opts = list(width.cutoff = 65),
tidy = TRUE,
message = TRUE,
warning = FALSE
)
# Chunk 5
# how to cite in Rmarkdown:
# https://rmarkdown.rstudio.com/authoring_bibliographies_and_citations.html
# find citation style files (csl) here:
# https://github.com/stackpr/csl-styles
# Here include the path to the libraries for each author. This code will copy/update the library each time the Rmarkdown file is compiled
# Alternatively authors ca
personal_libraries <- c(author_1 = "/home/m/Documents/mendeley_libraries/ohun_paper.bib", author_2 = "/home/neuro/Documents/export.bib")
# location of current Rmarkdown
if (!is.null(whereami::thisfile()))
rmd_dir <- dirname(whereami::thisfile()) else
rmd_dir <- NULL
if (is.null(rmd_dir)) rmd_dir <- file.path(rootdir, "manuscript")
# read personal library
personal_libraries <- personal_libraries[file.exists(personal_libraries)]
if (length(personal_libraries) > 0){
personal_bib <- suppressMessages(ReadBib(personal_libraries))
# read paper's references.bib if it exists
if (file.exists(file.path(rootdir, "references.bib"))){
combined_bib <- suppressMessages(ReadBib(file.path(rmd_dir, "references.bib")))
merge_bib <- suppressMessages(merge(personal_bib, combined_bib, fields.to.check = "title", ignore.case = TRUE))
} else
merge_bib <- personal_bib
# save combined references
WriteBib(bib = merge_bib, file = file.path(rmd_dir, "references.bib"), biblatex = TRUE)
}
# Chunk 6: read data
path_zebra_finch <- file.path(rootdir, "data/raw/taeniopygia/")
# read data
manual_ref_thy <- read.csv(file.path(rootdir, "//data/raw/thyroptera/", "manual_annotations_thyroptera.csv"))
manual_ref_tae <- read.csv(file.path(rootdir, "/data/processed/taeniopygia", "manual_selections_Taeniopygia.csv"))
# Chunk 9
feature_acoustic_data(path = path_zebra_finch)
```{r  optimize automated detection, eval = FALSE, echo = TRUE}
opt_det_train <- optimize_energy_detector(
reference = train_ref,
files = train_files,
threshold = c(1, 5),
hop.size = 11.6,
smooth = c(5, 10),
hold.time = c(0, 5),
min.duration = c(5, 15, 25),
max.duration = c(275, 300, 325),
bp = c(0.5, 10)
)
opt_det_train <- optimize_energy_detector(
reference = train_ref,
files = train_files,
threshold = c(1, 5),
hop.size = 11.6,
smooth = c(5, 10),
hold.time = c(0, 5),
min.duration = c(5, 15, 25),
max.duration = c(275, 300, 325),
bp = c(0.5, 10),
path = data_path
)
opt_det_train <- optimize_energy_detector(
reference = train_ref,
files = train_files,
threshold = c(1, 5),
hop.size = 11.6,
smooth = c(5, 10),
hold.time = c(0, 5),
min.duration = c(5, 15, 25),
max.duration = c(275, 300, 325),
bp = c(0.5, 10),
path = data_path, cores = 10
)
write.csv(opt_det_train , file = "./data/processed/taeniopygia/detection_optimization.csv")
best_param <- opt_det_train[which.max(opt_det_train$f.score), ]
det_test <- energy_detector(
files = test_files,
threshold = best_param$threshold,
hop.size = 11.6,
smooth = best_param$smooth,
hold.time = best_param$hold.time,
min.duration = best_param$min.duration,
max.duration = best_param$max.duration,
bp = c(0.5, 10),
path = data_path, cores = 10
)
write.csv(det_test, file.path(preproc_path, "detection_test_data.csv"), row.names = FALSE)
write.csv(det_test, file.path(preproc_path, "detection_test_data.csv"), row.names = FALSE)
